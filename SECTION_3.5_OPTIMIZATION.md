# 3.5 Оптимизация запросов через индексирование

Для повышения производительности системы были созданы индексы на наиболее часто используемых колонках таблиц. Индексирование позволяет СУБД PostgreSQL быстро находить необходимые строки без полного сканирования таблицы, что критично при работе с большими объемами данных.

## 3.5.1 Типы созданных индексов

В системе используются следующие типы индексов:

1. **B-tree индексы** — основной тип индексов PostgreSQL, эффективен для операций сравнения (=, <, >, <=, >=) и сортировки. Применяется для всех одиночных колонок.

2. **Композитные индексы** — индексы на нескольких колонках одновременно, оптимизируют JOIN-операции и запросы с множественными условиями фильтрации.

Всего в системе создано **25 индексов**, включая:
- 10 индексов для таблицы Users
- 5 индексов для таблицы Contests
- 2 индекса для таблицы Problems
- 7 индексов для таблицы Submissions (включая 2 композитных)
- 4 индекса для таблицы Standings
- 3 индекса для таблицы Audit_Log

## 3.5.2 Анализ эффективности индексирования

Для оценки эффективности созданных индексов был проведен анализ производительности запросов с использованием команды `EXPLAIN ANALYZE`. Данная команда выполняет запрос и возвращает подробную информацию о плане выполнения, включая фактическое время выполнения каждого этапа.

Тестирование проводилось на базе данных с **1000+ записями** в таблице submissions и **100 пользователями**. Для каждого запроса измерялось время планирования (Planning Time) и время выполнения (Execution Time) до и после создания индекса.

### Таблица 3.1 — Результаты анализа производительности запросов

| № | Описание запроса | Без индекса | С индексом | Ускорение |
|---|------------------|-------------|------------|-----------|
| 1 | Поиск всех посылок конкретного пользователя с JOIN по таблицам problems и contests. Индекс: `idx_submissions_user` на колонке `user_id` | **Planning:** 0.372 ms<br>**Execution:** 0.101 ms<br>Метод: Seq Scan | **Planning:** 0.235 ms<br>**Execution:** 0.030 ms<br>Метод: Index Scan | **3.4x**<br>(Planning: 1.6x) |
| 2 | Фильтрация посылок по статусу вердикта ('Accepted') с сортировкой по времени выполнения. Индекс: `idx_submissions_verdict` на колонке `verdict` | **Planning:** 0.588 ms<br>**Execution:** 0.119 ms<br>Метод: Seq Scan<br>Удалено фильтром: 1000 строк | **Planning:** 0.311 ms<br>**Execution:** 0.064 ms<br>Метод: Index Scan | **1.9x**<br>(Planning: 1.9x) |
| 3 | Агрегация данных с LEFT JOIN между users и submissions по условию `contest_id = 1`. Композитный индекс: `idx_submissions_contest_user` на `(contest_id, user_id)` | **Planning:** 0.429 ms<br>**Execution:** 0.206 ms<br>Метод: Seq Scan<br>Удалено фильтром: 1000 строк | **Planning:** 0.273 ms<br>**Execution:** 0.089 ms<br>Метод: Index Scan | **2.3x**<br>(Planning: 1.6x) |

### Анализ результатов

**Пример 1: Индекс на колонке user_id**

Запрос осуществляет выборку всех посылок конкретного пользователя с объединением таблиц `problems` и `contests`. До создания индекса PostgreSQL использовал последовательное сканирование таблицы submissions (Seq Scan), что привело к времени выполнения 0.101 мс. После создания B-tree индекса на колонке `user_id` планировщик запросов выбрал метод Index Scan, который позволил напрямую обратиться к нужным строкам. В результате время выполнения сократилось до 0.030 мс, обеспечив **ускорение в 3.4 раза**.

Индекс на `user_id` особенно эффективен, так как данная колонка является внешним ключом и часто используется в условиях WHERE и JOIN-операциях при формировании личных статистик пользователей.

**Пример 2: Индекс на селективной колонке verdict**

Запрос выполняет фильтрацию посылок по статусу вердикта ('Accepted') с последующей сортировкой по времени выполнения и ограничением результата (LIMIT 10). Колонка `verdict` имеет ограниченное число возможных значений (Accepted, Wrong Answer, Time Limit Exceeded и др.), что делает индекс высокоэффективным.

Без индекса СУБД выполняла Seq Scan всей таблицы с последующей фильтрацией, удалив 1000 строк из рассмотрения. С индексом PostgreSQL напрямую выбрала только строки с нужным значением verdict, сократив время выполнения с 0.119 мс до 0.064 мс — **ускорение в 1.9 раза**. Время планирования также уменьшилось с 0.588 мс до 0.311 мс благодаря более простому плану запроса.

**Пример 3: Композитный индекс для оптимизации JOIN**

Запрос выполняет сложную агрегацию данных с LEFT JOIN между таблицами `users` и `submissions` по двум условиям: `user_id` и `contest_id = 1`. Композитный индекс `idx_submissions_contest_user (contest_id, user_id)` позволяет СУБД эффективно находить строки, удовлетворяющие обоим условиям одновременно, минимизируя количество считываемых страниц данных.

До создания индекса PostgreSQL использовала Hash Left Join с последовательным сканированием таблицы submissions и фильтрацией 1000 строк по `contest_id`. После создания композитного индекса планировщик применил Index Scan, сразу находя нужные строки. Время выполнения сократилось с 0.206 мс до 0.089 мс — **ускорение в 2.3 раза**.

Композитные индексы особенно эффективны для запросов, которые регулярно фильтруют или объединяют таблицы по нескольким колонкам. В данном случае запрос используется для формирования турнирных таблиц конкретного соревнования — одна из наиболее частых операций в системе.

## 3.5.3 Общие выводы по оптимизации

Результаты анализа подтверждают эффективность выбранной стратегии индексирования:

1. **Среднее ускорение выполнения запросов составило 2.5x**, что существенно повышает отзывчивость системы при работе с большими объемами данных.

2. **Время планирования также уменьшилось в среднем в 1.7 раза**, что важно для часто выполняемых запросов.

3. **Композитные индексы показали высокую эффективность** для сложных JOIN-операций, подтверждая правильность их применения для связок `(contest_id, user_id)` и `(problem_id, verdict)`.

4. **Индексы на внешних ключах** (`user_id`, `contest_id`, `problem_id`) являются критически важными для производительности, так как эти колонки постоянно участвуют в JOIN-операциях.

При дальнейшем росте объема данных эффект от индексирования будет увеличиваться. Например, при увеличении числа записей в таблице submissions до 100,000 разница между Seq Scan и Index Scan может достигать **десятков и сотен раз**.

Важно отметить, что индексы требуют дополнительного дискового пространства (в среднем 10-20% от размера таблицы) и немного замедляют операции INSERT/UPDATE/DELETE за счет необходимости обновления индексных структур. Однако в системе управления соревнованиями операции чтения (SELECT) значительно преобладают над записью, поэтому выигрыш в производительности существенно превосходит издержки на поддержку индексов.

---

**Примечание:** Подробные планы выполнения запросов и скриншоты из pgAdmin4 приведены в Приложении Ж.
