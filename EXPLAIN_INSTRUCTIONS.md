# ИНСТРУКЦИЯ: Заполнение раздела 3.5 "Оптимизация запросов через индексирование"

## Шаг 1: Убедитесь, что база данных содержит достаточно данных

Если у вас мало данных, сгенерируйте больше используя `sql/07_generate_data.sql`:

```sql
-- В pgAdmin4 выполните:
\i 'C:/Education/DB_Labs/CP/sql/07_generate_data.sql'
```

Или через PowerShell:
```powershell
docker exec -i cp-db psql -U cpuser -d cpdb < sql/07_generate_data.sql
```

## Шаг 2: Откройте pgAdmin4

1. Подключитесь к базе данных:
   - Host: `db` (или `localhost` если подключаетесь извне)
   - Port: `5432`
   - Database: `cpdb`
   - Username: `cpuser`
   - Password: `cppassword`

2. Откройте Query Tool (Ctrl+T)

## Шаг 3: Выполните анализ для каждого примера

Откройте файл `sql/08_explain_analysis.sql` и следуйте инструкциям для каждого примера:

### ПРИМЕР 1: Поиск посылок пользователя

**ШАГ А:** Удалите индекс
```sql
DROP INDEX IF EXISTS idx_submissions_user;
```

**ШАГ Б:** Выполните EXPLAIN ANALYZE БЕЗ индекса:
```sql
EXPLAIN ANALYZE
SELECT 
    s.submission_id,
    s.verdict,
    s.execution_time_ms,
    s.memory_used_kb,
    p.title AS problem_title,
    c.title AS contest_title
FROM submissions s
JOIN problems p ON s.problem_id = p.problem_id
JOIN contests c ON s.contest_id = c.contest_id
WHERE s.user_id = 3
ORDER BY s.submitted_at DESC;
```

**ШАГ В:** Скопируйте вывод в таблицу (столбец "ДО оптимизации")  
Обратите внимание на:
- `Execution Time` (время выполнения)
- `Planning Time` (время планирования)
- Тип сканирования (`Seq Scan` = последовательное)

**ШАГ Г:** Создайте индекс:
```sql
CREATE INDEX idx_submissions_user ON submissions(user_id);
```

**ШАГ Д:** Снова выполните тот же EXPLAIN ANALYZE

**ШАГ Е:** Скопируйте вывод в таблицу (столбец "ПОСЛЕ оптимизации")  
Обратите внимание на:
- Уменьшение `Execution Time`
- Изменение типа сканирования (`Index Scan`)

**ШАГ Ж:** Сделайте скриншот результата в pgAdmin4

### ПРИМЕР 2: Фильтрация по вердикту

Повторите те же шаги для второго примера с индексом `idx_submissions_verdict`

### ПРИМЕР 3: Композитный индекс

Повторите те же шаги для третьего примера с индексом `idx_submissions_contest_user`

## Шаг 4: Заполните таблицу в пояснительной записке

Создайте таблицу в Word со следующей структурой:

```
┌──────────────┬─────────────────┬─────────────────┬──────────────┐
│   Запрос     │ ДО оптимизации  │ ПОСЛЕ оптимиз.  │ Ускорение    │
├──────────────┼─────────────────┼─────────────────┼──────────────┤
│ Пример 1:    │ Seq Scan        │ Index Scan      │              │
│ Поиск        │ Planning: X ms  │ Planning: X ms  │ Во сколько   │
│ посылок      │ Execution: Y ms │ Execution: Y ms │ раз быстрее  │
│ пользователя │                 │                 │              │
├──────────────┼─────────────────┼─────────────────┼──────────────┤
│ Пример 2:    │ ...             │ ...             │ ...          │
│ Фильтрация   │                 │                 │              │
│ по вердикту  │                 │                 │              │
├──────────────┼─────────────────┼─────────────────┼──────────────┤
│ Пример 3:    │ ...             │ ...             │ ...          │
│ Композитный  │                 │                 │              │
│ индекс JOIN  │                 │                 │              │
└──────────────┴─────────────────┴─────────────────┴──────────────┘
```

## Шаг 5: Добавьте текстовое описание

Для каждого примера напишите:

**Пример 1: Индекс на колонке user_id**

"Запрос осуществляет выборку всех посылок конкретного пользователя с объединением таблиц problems и contests. До создания индекса использовалось последовательное сканирование таблицы submissions (Seq Scan), что при большом объеме данных приводило к времени выполнения X мс. После создания B-tree индекса на колонке user_id планировщик выбрал Index Scan, что сократило время выполнения до Y мс, обеспечив ускорение в Z раз."

**Пример 2: Индекс на селективной колонке verdict**

"Запрос фильтрует посылки по статусу вердикта ('Accepted') с сортировкой по времени выполнения. Индекс на колонке verdict эффективен благодаря высокой селективности данных — небольшому числу возможных значений вердикта..."

**Пример 3: Композитный индекс**

"Запрос выполняет агрегацию данных с соединением таблиц users и submissions по условию contest_id = 1. Композитный индекс (contest_id, user_id) позволяет СУБД эффективно находить строки, удовлетворяющие обоим условиям JOIN, минимизируя количество считываемых страниц..."

## Шаг 6: Вставьте скриншоты

В Приложение (например, Приложение Ж) добавьте скриншоты из pgAdmin4:
1. Окно с EXPLAIN ANALYZE до оптимизации
2. Окно с EXPLAIN ANALYZE после оптимизации
3. Визуализация плана запроса (кнопка "Explain" с графическим представлением)

## Шаг 7: Восстановите все индексы

После завершения анализа выполните:
```sql
-- Из файла 08_explain_analysis.sql (секция в конце)
CREATE INDEX IF NOT EXISTS idx_submissions_user ON submissions(user_id);
CREATE INDEX IF NOT EXISTS idx_submissions_verdict ON submissions(verdict);
CREATE INDEX IF NOT EXISTS idx_submissions_contest_user ON submissions(contest_id, user_id);
-- ... остальные индексы
```

---

## Ожидаемые результаты

При наличии 1000+ записей в submissions вы должны увидеть:
- **Пример 1**: ускорение в 5-15 раз
- **Пример 2**: ускорение в 3-10 раз  
- **Пример 3**: ускорение в 10-20 раз (композитные индексы наиболее эффективны)

Если данных мало (< 100 записей), эффект может быть незначительным — PostgreSQL может выбрать Seq Scan даже при наличии индекса, так как для малых таблиц это быстрее.
